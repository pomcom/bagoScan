package services

import (
	"fmt"

	"github.com/pomcom/bagoScan/pkg/tools"
	"github.com/pomcom/bagoScan/pkg/tools/nmap"
	"github.com/pomcom/bagoScan/pkg/utils"
	"github.com/pomcom/bagoScan/pkg/utils/config"
)

type PentestService struct {
	configHandler config.ConfigHandler
	runner        utils.TestRunner
	fileHandler   utils.Filehandler
}

func (service PentestService) RunScan(target string) error {
	config, err := service.configHandler.ReadConfig()
	if err != nil {
		return err
	}
	service.runner = utils.NewTestRunner(config.ToolMap)

	outputs := service.runner.Run(target)

	for _, output := range outputs {
		fmt.Println(output.ToolName + ": " + output.Result)
		fileName := output.ToolName + "output.txt"
		err := service.fileHandler.WriteToFile(fileName, output.Result)
		if err != nil {
			return err
		}
	}
	return nil
}

func NewPentestService(configPath string) PentestService {
	configHandler := config.NewConfigHandler(configPath)
	config, err := configHandler.ReadConfig()
	if err != nil {
		panic(err)
	}
	fileHandler := utils.NewFilehandler("")
	return PentestService{configHandler: configHandler, fileHandler: fileHandler, runner: utils.NewTestRunner(config.ToolMap)}
}

/*
SingleToolRunnerService taktes just the tool name as a string.
The configFile does get set to "", since we want to ignore the config file in this case.
Another option would be to overload NewPentestService with the toolName
TODO not working - add functionality to run single Tool without using config file.
*/
func SingleToolRunnerService(toolName string) PentestService {
	toolMap := map[string]tools.Tool{toolName: nmap.Nmap{}}
	fileHandler := utils.NewFilehandler("")
	return PentestService{fileHandler: fileHandler, runner: utils.NewTestRunner(toolMap)}
}
