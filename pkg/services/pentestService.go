package services

import (
	"fmt"

	"github.com/pomcom/bagoScan/pkg/tools"
	"github.com/pomcom/bagoScan/pkg/utils"
	"github.com/pomcom/bagoScan/pkg/utils/config"
)

type PentestService struct {
	configHandler config.ConfigHandler
	runner        utils.TestRunner
	fileHandler   utils.Filehandler
}

func (service PentestService) RunScan(target string) error {
	config, err := service.configHandler.ReadConfig()
	if err != nil {
		return err
	}
	service.runner = utils.NewTestRunner(config.ToolMap)

	outputs := service.runner.Run(target)

	for _, output := range outputs {
		fmt.Println(output.ToolName + ": " + output.Result)
		fileName := output.ToolName + "output.txt"
		err := service.fileHandler.WriteToFile(fileName, output.Result)
		if err != nil {
			return err
		}
	}
	return nil
}

func NewPentestService(configPath string) PentestService {
	configHandler := config.NewConfigHandler(configPath)
	config, err := configHandler.ReadConfig()
	if err != nil {
		panic(err)
	}
	fileHandler := utils.NewFilehandler("")
	return PentestService{configHandler: configHandler, fileHandler: fileHandler, runner: utils.NewTestRunner(config.ToolMap)}
}

/*
SingleToolRunnerService taktes just the tool name as a string.
The configFile does get set to "", since we want to ignore the config file in this case.
Another option would be to overload NewPentestService with the toolName
*/
func SingleToolRunnerService(toolName string) PentestService {
	//Set empty configFile, since we want to ignore it here
	configHandler := config.NewConfigHandler("")
	config, err := configHandler.ReadConfig()
	if err != nil {
		panic(err)
	}
	toolMap := config.ToolMap
	if toolName != "" {
		tool, ok := config.ToolMap[toolName]
		if !ok {
			panic(fmt.Errorf("tool not found: %s", toolName))
		}
		toolMap = map[string]tools.Tool{toolName: tool}
	}
	fileHandler := utils.NewFilehandler("")
	return PentestService{configHandler: configHandler, fileHandler: fileHandler, runner: utils.NewTestRunner(toolMap)}
}
